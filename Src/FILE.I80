; биты атрибутов для функций SetAtr и GetAtr
  FATTR_SD_BIT  equ 1
  FATTR_RW_BIT  equ 2


;------------------------------------------------------------------------
; подсчет количества дисков в системе
;------------------------------------------------------------------------
; на выходе:
;       nDisks  - количество дисков в системе
dsk_GetCount:
        mvi     C, 0
    @@mkdsk:
        push    B
        call    0DA1Bh          ; проверяем наличие диска
        pop     B
        mov     A, L
        ora     H
        jz      @@mkdskend
        inr     C
        mov     A, C
        cpi     12+1            ; максимум 12 дисков
        jc      @@mkdsk
    @@mkdskend:
        mov     A, C
        sta     nDisks
        ret

;------------------------------------------------------------------------
; инициализация дисковой подсистемы
;------------------------------------------------------------------------
; - задается дефолтный DMA
; - задается дефолтный FCB
; - сбрасываются диски (LOGIN) и устанавливается диск 'A:'
; - удаляется файл '$$$.SUB'
dsk_Reset:
        ; устанавливаем дефолтные DMA и FCB
        call    dsk_DefIO
        ; сбрасываем диски
        mvi     C, 0Dh
        jmp     5               ; Clr(LOGIN) | dsk_SetDMA(80h) | dsk_SetActive('A:')


;------------------------------------------------------------------------
; получает DPB любого диска
;------------------------------------------------------------------------
; на входе:
;       C       - диск (0 - A, 1 - B, 2 - C, ...)
; на выходе:
;       dbpStruc - структура DPB
; save: DE, HL
;GetDPB:
;        push    H
;        push    D
;        lda     CUR_DRIVE       ; call    GetDsk
;        ani     0Fh
;        mov     B, A
;        push    B               ; сохраняем текущий и заданный диски
;        cmp     C
;        cnz     dsk_SetActive   ; устанавливаем новый тек. диск
;        call    dsk_CurDPB
;        pop     B
;        mov     A, C
;        mov     C, B
;        cmp     C
;        cnz     dsk_SetActive   ; устанавливаем прежний тек. диск
;        pop     D
;        pop     H
;        ret

;------------------------------------------------------------------------
; получает DPB текущего диска
;------------------------------------------------------------------------
; на выходе:
;       dbpStruc - структура DPB
dsk_CurDPB:
        mvi     C, 31
        call    5
        lxi     D, dpbStruc
        mvi     C, dpbSize
        jmp     memcpy


;------------------------------------------------------------------------
; вычисляет размер свободного места на текущем диске
;------------------------------------------------------------------------
; на выходе:
;       HL      - свободное место в Кб
;       DE      - остаток в байтах
dsk_GetFree:
        call    dsk_CurDPB      ; получаем DPB текущего диска
        xra A
        sta     DskFree
        sta     DskFree+1
        ; вычисляем размер кластера в байтах
        lda     dpbBlkMask
        mov     L, A
        mvi     H, 0
        inx     H
        mvi     C, 7
        call    shl16
        shld    BlkSize         ; BlockSize = (DBP.BLM+1) * 128
        ; получаем общее количество блоков на диске
        lhld    dpbDskMax
        inx     H
        push    H               ; [SP]  - DPB.DSM
        ; получаем адрес таблицы векторов распределения памяти
        mvi     C, 27
        call    5               ; HL = &Vectors[]
        ; [SP]  - DPB.DSM
        ; HL    - &Vector[]
        lxi     D, 0            ; DE - accum
    @dskfr_vecloop:             ; while (DSM)
        mov     B, M            ; B = *vectors[]
        inx     H
        mvi     C, 8
        xthl                    ; HL - DPB.DSM / [SP] - &Vectors[]
    @dskfr_byte:                ; while (C)
        mov     A, B
        rar
        mov     B, A
        jc      @dskfr_next
        ; DE += BlockSize
        lda     BlkSize
        add     E
        mov     E, A
        lda     BlkSize+1
        adc     D
        mov     D, A
    @dskfr_kb:                  ; while (DE >= 1024)
        mov     A, D
        cpi     4
        jc      @dskfr_next
        mov     A, D
        sui     4
        mov     D, A            ; DE = DE - 1024
        ; DskFree++
        lda     DskFree
        adi     1
        sta     DskFree
        lda     DskFree+1
        aci     0
        sta     DskFree+1
        jmp     @dskfr_kb
    @dskfr_next:
        dcx     H
        mov     A, H
        ora     L
        jz      @dskfr_exit
        dcr     C
        jnz     @dskfr_byte
        xthl                    ; HL - &Vectors[]
        jmp     @dskfr_vecloop
    @dskfr_exit:
        pop     H
        lhld    DskFree         ; return DskFree
        ret

;while (DPB.DSM)
;{
;    B = pVector++
;    C = 8;
;    while (C)
;    {
;        ROL(B);
;        if CARRY == 0
;        {
;            DE = DE + BlockSize
;            while (DE >= 1024)
;            {
;                DE = DE - 1024
;                DskFree++;
;            }
;        }
;        C--;
;        DPB.DSM--;
;        if (DPB.DSM == 0)
;            return;
;    }
;}



;------------------------------------------------------------------------
; устанавливает новый текущий диск
;------------------------------------------------------------------------
; на входе:
;       A       - диск (0 - A, 1 - B, 2 - C, ...)
; save: DE, HL
dsk_SetActive:
        push    D
        push    H
        push    B
        mov     E, A
        lda     CUR_DRIVE
        ani     0F0h
        ora     E
        sta     CUR_DRIVE
        mvi     C, 14
        jmp     callRW
;        call    5
;        pop     B
;        pop     H
;        pop     D
;        ret

; A - user (0-15)
dsk_SetUser:
        push    H
        push    B
        mov     E, A            ; E = UserNo
        ral
        ral
        ral
        ral
        ani     0F0h
        mov     C, A
        lda     CUR_DRIVE
        mov     B, A
        ani     0F0h
        cmp     C
        jz      @dsk_userdone
        mov     A, B
        ani     0Fh
        ora     C
        sta     CUR_DRIVE
        mvi     C, 32
        call    5
    @dsk_userdone:
        pop     B
        pop     H
        ret

;------------------------------------------------------------------------
; устанавливает дефолтные адреса DMA и FCB
;------------------------------------------------------------------------
dsk_DefIO:
        call    dsk_DefFCB

;------------------------------------------------------------------------
; устанавливает дефолтный адрес DMA
;------------------------------------------------------------------------
dsk_DefDMA:
        lxi     B, DEF_DMA
;------------------------------------------------------------------------
; назначает новый адрес DMA
;------------------------------------------------------------------------
; на входе:
;       BC      - новый адрес буфера DMA
; save: DE, HL
dsk_SetDMA:
        push    H
        push    D
        mov     L, C
        mov     H, B
  @set_dma:
        shld    dmaPtr
        xchg
        mvi     C, 26
        call    5
        pop     D
        pop     H
        ret

;------------------------------------------------------------------------
; инкрементируем DMA на след. позицию
;------------------------------------------------------------------------
; на входе:
;       dmaPtr  - текущий адрес DMA
; на выходе:
;       dmaPtr  - след. адрес (dmaPtr += 128)
; save: DE, HL, BC
dsk_IncDMA:
        push    H
        push    D
        lhld    dmaPtr
        lxi     D, 128
        dad     D
        jmp     @set_dma


;------------------------------------------------------------------------
; устанавливает дефолтный адрес FCB
;------------------------------------------------------------------------
dsk_DefFCB:
        lxi     B, DEF_FCB
;------------------------------------------------------------------------
; назначает активным новый блок FCB
;------------------------------------------------------------------------
; на входе:
;       BC      - адрес нового FCB
; save: DE, HL
dsk_SetFCB:
        push    H
        mov     L, C
        mov     H, B
        shld    fcbPtr
        pop     H
        ret







;------------------------------------------------------------------------
; Инициализирует структуру FCB
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M ("[A:]????????STC")
;                 если отсутствует диск, то берется текущий
;       fcbPtr  - указатель на текущий FCB
; на выходе:
;       DE      - указатель на FCB
dsk_MakeFCB:
        inx     B
        ldax    B
        dcx     B
        cpi     ':'
        mvi     A, 0
        jnz     @filfcb
        ldax    B
        inx     B
        inx     B
        sui     ('A'-1)
    @filfcb:
        lhld    fcbPtr
        push    H
        ; задаем дисковод
        mov     M, A            ; FCB[0] = nDisk
        inx     H
        ; задаем имя файла
        call    @cpyfname       ; FCB[1-11] = filename.ext
        ; обнуляем остальные поля
        mvi     E, 36-12
        xra     A
    @fffsz:
        mov     M, A
        inx     H
        dcr     E
        jnz     @fffsz
        pop     D
        ret

    @cpyfname:
        ; copy name
        mvi     E, 8
        call    @copyname
        mvi     E, 3
    @copyname:
        ldax    B
        call    fCheck
        jz      @copyspc
        mov     M, A
        inx     B
        inx     H
        dcr     E
        jnz     @copyname
        ret
    @copyspc:
        mvi     M, ' '
        inx     B
        inx     H
        dcr     E
        jnz     @copyspc
        ret




;------------------------------------------------------------------------
; Возвращает размер файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
;       fcbPtr  - указатель на текущий FCB
; на выходе:
;       HL      - размер файла в записях (0 - если была ошибка или переполнение)
file_Size:
        call    dsk_MakeFCB
        ; вызываем BDOS
        push    D
        mvi     C, 35
        call    5
        lxi     H, 0
        pop     D
        lxi     H, 33
        dad     D               ; HL - указатель на размер
        mov     E, M
        inx     H
        mov     D, M
        xchg
        ret

;------------------------------------------------------------------------
; Поиск первого вхождения файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
;       fcbPtr  - указатель на текущий FCB
; на выходе:
;       HL      - указатель на запись DIRREC в буфере обмена (0 - ничего нет)
file_FindFirst:
        call    dsk_MakeFCB
        ; вызываем BDOS
        mvi     C, 17
        call    5
        mov     C, A
        jmp     DirRec


;------------------------------------------------------------------------
; Поиск очередного вхождения файла
;------------------------------------------------------------------------
; на выходе:
;       HL      - указатель на запись DIRREC в буфере обмена (0 - конец поиска)
; destroy: A, HL
file_FindNext:
        lhld    fcbPtr
        xchg
        mvi     C, 18
        call    5
        mov     C, A

;------------------------------------------------------------------------
;  Возвращает указатель на запись DIRREC в буфере обмена
;------------------------------------------------------------------------
; на входе:
;       C       - номер записи в буфере обмена (0 - 7)
; на выходе:
;       HL      - указатель на запись DIRREC в текущем буфере обмена
; destroy: A, BC
DirRec:
        lxi     H, 0
        mov     A, C
        cpi     0FFh
        rz
        ral
        ral
        ral
        ral
        ral
        ani     11100000b
        mov     C, A
        mvi     B, 0
        lhld    dmaPtr
        dad     B
        ret




;------------------------------------------------------------------------
; установка атрибутов файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
;       E       - bit: 0 - system/dir
;                      1 - read only
; save: BC
SetAtr:
        push    B
        push    D
        call    dsk_MakeFCB
        pop     H
        xchg                    ; E - attr bits
        push    H               ; save FCB ptr
        ; формируем биты атрибутов
        lxi     B, 10
        dad     B               ; HL = &FCB[10]
        mvi     C, 2
    @setatr_loop:
        mov     A, M
        ani     7Fh
        mov     B, A            ; B = FCB[i] & 0x7F
        mov     A, E
        rrc                     ; bit[0] --> bit[7]
        mov     E, A
        ani     80h
        ora     B
        mov     M, A
        dcx     H
        dcr     C
        jnz     @setatr_loop
        ; устанавливаем атрибуты
        pop     D               ; DE = &FCB
        mvi     C, 30
        call    5
        pop     B
        ret


;------------------------------------------------------------------------
; получение атрибутов файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
; на выходе:
;       A       - bit: 0 - system/dir
;                      1 - read only
; save: BC
GetAtr:
        push    B
        call    file_FindFirst
        pop     B
        mov     A, L
        ora     H
        rz
        lxi     D, 9
        dad     D
        mov     A, M            ; A = R/W | R/O
        rlc
        rlc
        ani     10b
        mov     E, A
        inx     H
        mov     A, M
        rlc
        ani     1
        ora     E
        ret



;------------------------------------------------------------------------
; удаление файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
; на выходе:
;       CF      - 0: нормальное завершение, 1: ошибка
; save: DE, HL
file_Delete:
        push    D
        push    H
        ; снимаем атрибуты
        mvi     E, 0
        call    SetAtr
        ; удаляем файл
        call    dsk_MakeFCB
        mvi     C, 19
fResult:
        call    5
        pop     H
        pop     D
        cpi     0FFh
        cmc
        ret


;------------------------------------------------------------------------
; переименование файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
;       DE      - новое имя в формате CP/M (без диска!)
; на выходе:
;       CF      - 0: нормальное завершение, 1: ошибка
; save: DE, HL
file_Rename:
        push    D
        push    H
        push    D
        call    dsk_MakeFCB
        lxi     H, 16
        dad     D
        mvi     M, 0
        inx     H
        pop     B
        push    D
        call    @cpyfname
        pop     D
        mvi     C, 17h
        jmp     fResult





;------------------------------------------------------------------------
; открытие файла (для операций чтения/записи)
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
; на выходе:
;       HL      - указатель на текущий FCB
;       CF      - 0: нормальное завершение, 1: ошибка
; save: DE
file_Open:
        push    D
        call    dsk_MakeFCB
        push    D
        mvi     C, 15
        jmp     fResult



;------------------------------------------------------------------------
; создание файла
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M (типа: "[A:]FILENAMEEXT")
;                 если отсутствует диск, то берется текущий
; на выходе:
;       HL      - указатель на текущий FCB
;       CF      - 0: нормальное завершение, 1: ошибка
; save: DE
file_Create:
        push    D
        call    dsk_MakeFCB
        push    D
        mvi     C, 22
        jmp     fResult




;------------------------------------------------------------------------
; закрытие файла
;------------------------------------------------------------------------
; на входе:
;       BC      - FCB файла
file_Close:
        push    B
        pop     D
        mvi     C, 16
        jmp     5


;------------------------------------------------------------------------
; последовательное чтение файла
;------------------------------------------------------------------------
; на входе:
;       BC      - FCB файла
; на выходе:
;       ZF      - 1:   нормальное завершение, еще не все считали
;                 0:   достигли конца файла
; save: HL, DE, BC
file_Read:
        push    D
        push    H
        push    B
        mov     E, C
        mov     D, B
        mvi     C, 20
callRW:
        call    5
        pop     B
        pop     H
        pop     D
        ora     A
        ret


;------------------------------------------------------------------------
; последовательная запись в файл
;------------------------------------------------------------------------
; на входе:
;       BC      - FCB файла
; на выходе:
;       ZF      - 1:   нормальное завершение
;                 0:   системная ошибка
file_Write:
        push    D
        push    H
        push    B
        mov     E, C
        mov     D, B
        mvi     C, 21
        jmp     callRW


;------------------------------------------------------------------------
; прямое чтение файла
;------------------------------------------------------------------------
; на входе:
;       BC      - FCB файла
;       DE      - номер записи
; на выходе:
;       ZF      - 1:   нормальное завершение, еще не все считали
;                 0:   достигли конца файла
; save: HL, DE, BC
file_ReadRec:
        push    D
        push    H
        push    B
        lxi     H, 33
        dad     B               ; HL = &FCB[номер записи]
        mov     M, E
        inx     H
        mov     M, D
        inx     H
        mvi     M, 0
        mov     E, C
        mov     D, B
        mvi     C, 33
        jmp     callRW


;========================================================================

;------------------------------------------------------------------------
; проверка символа на корректность для имени файла
;------------------------------------------------------------------------
; на входе:
;       A       - символ
; на выходе:
;       A       - символ (по необходимости в верхнем регистре)
;       ZF      - 1: символ не корректен;
;                 0: ок
fCheck:
        cpi     '!'
        jc      @fnchkerr
        cpi     80h
        jnc     @fnchkerr
        cpi     '_'
        rz
        cpi     '='
        rz
        cpi     '.'
        rz
        cpi     ';'
        rz
        cpi     ':'
        rz
        cpi     '<'
        rz
        cpi     '>'
        rz
;        cpi     '?'
;        rz
;        cpi     '*'
;        rz
        ; char up
        cpi     'a'
        jc      @fnchkret
        cpi     'z'+1
        jnc     @fnchkret
        ani     5Fh
    @fnchkret:
        ora     A
        ret
    @fnchkerr:
        cmp     A
        ret


