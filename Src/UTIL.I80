;------------------------------------------------------------------------
; возвращает длину asciz-строки
;------------------------------------------------------------------------
; на входе:
;       BC      - строка с завершающим нулем
; на выходе:
;        A      - длина строки
; destroy:
strlen:
        push    H
        mvi     L, 0
    @@slenlp:
        ldax    B
        ora     A
        jz      @@slen_exit
        inx     B
        inr     L
        jnz     @@slenlp
        dcr     L               ; стока больше 255 символов, усекаем до 255
    @@slen_exit:
        mov     A, L
        pop     H
        ret


;------------------------------------------------------------------------
; возвращает вхождение символа в строку
;------------------------------------------------------------------------
; на входе:
; на входе:
;       BC      - строка с завершающим нулем
;        A      - искомый символ
; на выходе:
;       ZF      - 1: символа нет в строке
;               - 0: в рег. A номер позиции символа в строке (нач. с 1)
; save: BC, HL
strchr:
        push    B
        push    D
        mov     E, A
        mvi     D, 0
    @schr_loop:
        ldax    B
        ora     A
        jz      @schr_none
        inr     D
        cmp     E
        jz      @schr_done
        inx     B
        jmp     @schr_loop
    @schr_none:
        mvi     D, 0
    @schr_done:
        mov     A, D
        ora     A
        pop     D
        pop     B
        ret



; [HL] -> [DE], with C count
; save: BC
memcpy:
        push    B
    @memcopy:
        mov     A, M
        stax    D               ; [DE] = [HL]
        inx     H               ; HL++
        inx     D               ; DE++
        dcr     C
        jnz     @memcopy        ; while (C != 0)
        pop     B
        ret


; fill [HL] with A, counts in C
memset:
        mov     E, A
    @msetlp:
        mov     M, E
        inx     H
        dcr     C
        jnz     @msetlp
        ret



; compare [DE] & [HL] with C count
; на выходе:
;            | C Z
;    --------+----
;    DE = HL | 0 1
;    DE > HL | 0 0
;    DE < HL | 1 0
memcmp:
    @mcmplp:
        ldax    D
        sub     M
        rnz
        inx     D
        inx     H
        dcr     C
        jnz     @mcmplp
        ret



;------------------------------------------------------------------------
; перевод беззнакового числа в строку
;------------------------------------------------------------------------
; на входе:
;    BC         - 16-битное число
;    DE         - адрес буфера под строку
; на выходе:
;    DE         - указатель на завершающий ноль
; save: HL
utoa:
        push    H
        mov     L, C
        mov     H, B
        mvi     A, '0'          ; флаг пропуска первых нулей
        lxi     B, -10000
        call    @@dectoa
        lxi     B, -1000
        call    @@dectoa
        lxi     B, -100
        call    @@dectoa
        lxi     B, -10
        call    @@dectoa
        mov     A, L
        ori     '0'
        stax    D
        ; завершаем строку
        inx     D
        xra     A
        stax    D
        pop     H
        ret
  @@dectoa:
        push    D
        mov     D, A
        mvi     A, '0'-1
    @@decialoop:
        inr     A
        dad     B
        jc      @@decialoop
        push    PSW
        mov     A, L
        sbb     C
        mov     L, A
        mov     A, H
        sbb     B
        mov     H, A
        pop     PSW
        cmp     D
        pop     D
        rz
        stax    D
        inx     D
        mvi     A, 0FFh         ; закончили пропуск нулей
        ret


;------------------------------------------------------------------------
; сравнение чисел без знака
;------------------------------------------------------------------------
; на входе:
;    DE & HL    - сравниваемые 16-битные беззнаковые значения
; на выходе:
;            | C Z
;    --------+----
;    DE = HL | 0 1
;    DE > HL | 0 0
;    DE < HL | 1 0
; destroy: A
ucomp:
        mov     A, D
        cmp     H
        rnz
        mov     A, E
        cmp     L
        ret

;------------------------------------------------------------------------
; вычитание HL = HL - DE
;------------------------------------------------------------------------
sub16:
        mov     A, L
        sub     E
        mov     L, A
        mov     A, H
        sbb     D
        mov     H, A
        ret


;------------------------------------------------------------------------
; сдвиг влево HL = HL << C
;------------------------------------------------------------------------
shl16:
        xra     A
        mov     A, L
        ral
        mov     L, A
        mov     A, H
        ral
        mov     H, A
        dcr     C
        jnz     shl16
        ret



;------------------------------------------------------------------------
; деление 32-х разрядного числа на 16-ти разрядное
;------------------------------------------------------------------------
; на входе:
;    HL:DE      - делимое
;    BC         - делитель
; на выходе:
;    DE         - частное
;    HL         - остаток
;    cf         - 1: произошло переполнение результата
ldiv:
        xra     A               ; A - счетчик бит
    @@div_loop:
        dad     H               ; сдвигаем остаток влево
        push    PSW
        xchg
        dad     H               ; сдвигаем младшую часть делимого
        xchg
        jnc     @@div_1         ; -> из младшей части выдвинут ноль
        inx     H               ;                              единица
    @@div_1:
        mov     A, L            ; вычитаем делитель из остатка
        sub     C
        mov     L, A
        mov     A, H
        sbb     B
        mov     H, A
        jc      @@div_2         ; -> цифра частного равна нулю
        pop     PSW
    @@div_3:
        inx     D               ; цифра частного равна единице
        jmp     @@div_4
    @@div_2:
        pop     PSW
        jc      @@div_3
        dad     B               ; восстанавливаем остаток
    @@div_4:
        adi     10h             ; инкремент счетчика бит
        jnc     @@div_loop
        ora     A               ; сброс флага переполнения
        ret


;------------------------------------------------------------------------
; сложение 32-х разрядных чисел
;------------------------------------------------------------------------
; на входе:
;    HL         - первое слагаемое и результат
;    BC         - второе слагаемое
; на выходе:
;    HL         - HL+BC
;    CF         - флаг переполнения результата
ladd:
        push    H
        push    B
        ldax    B
        add     M
        mov     M, A
        inx     B
        inx     H
        ldax    B
        adc     M
        mov     M, A
        inx     B
        inx     H
        ldax    B
        adc     M
        mov     M, A
        inx     B
        inx     H
        ldax    B
        adc     M
        mov     M, A
        pop     B
        pop     H
        ret




;=============================================================================
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
;░░░░░░░░░░░░░░░░░░░░░░░░░░ КОНВЕРТАЦИЯ ИМЕН ФАЙЛОВ ░░░░░░░░░░░░░░░░░░░░░░░░░░
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
;=============================================================================


;------------------------------------------------------------------------
; проверяет расширение файла в формате NC на предмет ком-файла
;------------------------------------------------------------------------
; на входе:
;       HL      - имя файла в формате NC             (' FILENAME EXT   ')
; на выходе:
;       ZF      - 1: это COM-файл
;                 0: это не командный файл
NCisCOM:
        push    H
        push    D
        lxi     B, 10
        dad     B
        lxi     D, szCOM
        mvi     C, 3
        call    memcmp
        pop     D
        pop     H
        ret

szCOM:  db 'COM'

;------------------------------------------------------------------------
; конвертирование имени файла из формата NC в формат CP/M
;------------------------------------------------------------------------
; на входе:
;       HL      - имя файла в формате NC             (' FILENAME EXT   ')
;       DE      - буфер под имя файла в формате CP/M ('FILENAMEEXT')
; прим: теряются атрибуты файла
NC2CPM:
        inx     H               ; пропускаем флаг выделения файла
        ; имя файла
        mvi     C, 8
        call    memcpy
        inx     H               ; пропускаем байт атрибутов файла
        mvi     C, 3
        jmp     memcpy


;------------------------------------------------------------------------
; конвертирование имени файла из формата NC в формат DOS
;------------------------------------------------------------------------
; на входе:
;       HL      - имя файла в формате NC             (' FILENAME EXT   ')
;       DE      - буфер под имя файла в формате DOS  ('FILENAME.EXT')
NC2DOS:
        push    D
        lxi     D, 80h          ; времянка
        push    D
        call    NC2CPM
        pop     B
        pop     D
        call    CP2DOS
        ret

;------------------------------------------------------------------------
; получение имени файла из формата NC (без расширения)
;------------------------------------------------------------------------
; на входе:
;       HL      - имя файла в формате NC             (' FILENAME EXT   ')
;       DE      - буфер под имя файла ('FILENAME', #0)
NC2NAME:
        inx     H               ; пропускаем флаг выделения файла
        mvi     C, 8
    @@ncshlp:
        mov     A, M
        cpi     ' '
        jz      @ncshex
        stax    D
        inx     H
        inx     D
        dcr     C
        jnz     @@ncshlp
    @ncshex:
        ; завершающий ноль
        xra     A
        stax    D
        ret

;------------------------------------------------------------------------
; конвертирование имени файла из формата CP/M в формат NC
;------------------------------------------------------------------------
; на входе:
;       HL      - имя файла в формате CP/M           ('FILENAMEEXT')
;       DE      - буфер под имя файла в формате NC   (' FILENAME EXT   ')
CPM2NC:
        ; символ выделения файла
        mvi     A, ' '
        stax    D
        inx     D
        inx     H
        ; имя файла
        mvi     C, 8
    @@cpncfn:
        mov     A, M
        ani     7Fh
        stax    D
        inx     H
        inx     D
        dcr     C
        jnz     @@cpncfn
        push    D               ; сохраняем позицию под флаг системного файла
        mvi     A, ' '
        stax    D
        inx     D
        ; расширение
        mvi     B, 3
    @@cpncext:
        mov     A, M
        ani     7Fh
        stax    D
        inx     D
        ; байт атрибутов
        mov     A, M
        inx     H
        rlc                     ; бит атрибута в CF
        mov     A, C
        ral                     ; переносим бит в C
        mov     C, A
        dcr     B
        jnz     @@cpncext
        ; атрибуты
        pop     H
        mov     A, C            ; A - ?????| R/W | S/D | ?
        ani     2
        jz      @@cpncfil
        mvi     M, 7Fh          ; атрибут системного файла
    @@cpncfil:
        xchg
        mvi     A, ' '
        mvi     C, LST$DATA-1-8-1-3
        call    memset
        ret


;------------------------------------------------------------------------
; конвертация имени файла из формата CP/M в формат DOS
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате CP/M
;       DE      - буфер под имя файла в формате DOS
; save: HL
CP2DOS:
        push    H
        mvi     L, 10           ; предполагаем полное имя (с диском)
        inx     B
        ldax    B
        dcx     B
        cpi     ':'
        jz      @cpm2dos
        ; это имя без диска
        dcr     L
        dcr     L
    @cpm2dos:
        ; преобразуем имя файла
        ldax    B
        cpi     21h
        jc      @cpnfx
        stax    D
        inx     D
    @cpnfx:
        inx     B
        dcr     L
        jnz     @cpm2dos
        ; ставим точку
        mvi     A, '.'
        stax    D
        inx     D
        ; преобразуем расширение файла
        mvi     L, 3
    @cpelp:
        ldax    B
        cpi     21h
        jc      @cpefx
        stax    D
        inx     D
    @cpefx:
        inx     B
        dcr     L
        jnz     @cpelp
        ; ставим завершающий ноль
        xra     A
        stax    D
        pop     H
        ret


;------------------------------------------------------------------------
; конвертация имени файла из формата DOS в формат CP/M
;------------------------------------------------------------------------
; на входе:
;       BC      - имя файла в формате DOS            ('FILENAME.EXT', #[0..20h])
;       DE      - буфер под имя файла в формате CP/M ('FILENAMEEXT')
DOS2CP:
        push    H
        xchg
        ; конвертируем имя файла
        mvi     E, 8
        mvi     D, 0            ; D - длина DOS-имени файла
    @d2cp_copyname:
        ldax    B
        call    fCheck
        jz      @d2cp_blankname
        mov     M, A
        inx     H
        inx     B
        inr     D
        dcr     E
        jnz     @d2cp_copyname
        ; скопировали все 8 символов, ожидаем точку или конец строки (<= 20h)
        ldax    B
        call    fCheck
        jz      @d2cp_doext
        ; непредвиденный символ, заканчиваем
        mvi     E, 3
        jmp     @d2cp_blankext  ; -> забиваем расширение пробелами
        ; дополняем имя файла пробелами (до 8 символов)
    @d2cp_blankname:
        mvi     M, ' '
        inx     H
        dcr     E
        jnz     @d2cp_blankname
    @d2cp_doext:
        mvi     E, 3
        cpi     '.'
        jnz     @d2cp_blankext  ; -> забиваем расширение пробелами
        inr     D
        inx     B
    @d2cp_copyext:
        ldax    B
        call    fCheck
        jz      @d2cp_blankext  ; -> забиваем остаток расширения пробелами
        inr     D
        mov     M, A
        inx     H
        inx     B
        dcr     E
        jnz     @d2cp_copyext
        jmp     @d2cp_done
    @d2cp_blankext:
        mvi     M, ' '
        inx     H
        dcr     E
        jnz     @d2cp_blankext
    @d2cp_done:
        pop     H
        mov     A, D
        ret


