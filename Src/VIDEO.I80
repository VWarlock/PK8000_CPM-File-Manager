INTJMP  equ 0F86Eh ; (1) переход на пользовательский обработчик прерывания
INTADR  equ 0F86Fh ; (2) адрес пользовательского обработчика

        ; ; блок параметров текущего видеорежима (VIDMODE)
VIDTBL  equ 0FA00h
SCRFUL  equ 0FA00h ; (1) полная ширина экрана, включая не отображаемые области
LFHIDE  equ 0FA01h ; (1) кол. не отображаемых символов слева
SCRWDT  equ 0FA02h ; (1) видимая ширина экрана
SCRHGT  equ 0FA03h ; (1) кол. строк экрана
RTHIDE  equ 0FA04h ; (1) кол. не отображаемых символов справа
BUFSCR  equ 0FA05h ; (2) адрес буфера экрана реж. 0 и 1
CLRTAB  equ 0FA07h ; (2) адрес таб. цвета реж. 1
CHRGEN  equ 0FA09h ; (2) адрес знакогенератора реж. 0 и 1

CURBKGR equ 0FA1Ch ; (1) символ фона под курсором
CURBADR equ 0FA1Eh ; (2) адрес видеопамяти сохраненного фона под курсором
CURX    equ 0FA21h ; (1) положение курсора на экране
CURY    equ 0FA22h ; (1)

VMODE   equ 0FD8Ch ; (1) номер текущего видеорежима

CURHIDE equ 0FDBEh ; (1) флаг видимости/скрытия курсора (FF - скрыт)

PALUPD  equ 0FDEBh ; (1) флаг необходимости обновлять регистры палитры
INTVID  equ 0FEDCh ; (244) свободная область памяти, используем под обработчик
BUFSAV  equ 0FFD0h ; (40) буфер для сохранения фона под курсором окна


;============================================================================;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░ УСТАНОВКА ВИДЕОРЕЖИМОВ ░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;============================================================================;




;------------------------------------------------------------------------
; установка видеорежима 1
;------------------------------------------------------------------------
vidInit:
        lxi     B, regsMode1
        call    vidSetRegs
        in      84h
        ani     0CFh            ; текстовый, 32 символа
        out     84h             ; видеопамять в старшие адреса (C000h)
        ; ---- патчим палитру
        call    SetPatch
        ; устанавливаем палитру
        call    vidDefPalette
        jmp     vidOn

;------------------------------------------------------------------------
; установка видеорежима 0
;------------------------------------------------------------------------
vidDone:
        lxi     B, regsMode0
        call    vidSetRegs
        in      84h
        ani     0CFh
        ori     20h             ; текстовый, 40 символов
        out     84h
        ; убираем обработчик прерывания
        mvi     A, 0C9h
        sta     0F86Eh          ; JUMP на пользовательский обработчик прерывания

vidOn:
        call    vidDispOn       ; разрешаем отображение на экран
        call    vidClear
        ; разрешаем отображение курсора
        mvi     A, 0h
        sta     CURHIDE

        ret


;--------------------------------------------------------------------
; in:
;   BC  - структура VIDMODE
vidSetRegs:
        call    vidDispOff
        ; переносим таблицу параметров видеорежима в системную память
        lxi     H, VIDTBL
        mvi     E, 11
    vsetlp:
        ldax    B
        inx     B
        mov     M, A
        inx     H
        dcr     E
        jnz     vsetlp
        ldax    B
        sta     VMODE
        ; обновляет регистры адресов буферов экрана
        lda     BUFSCR+1        ; A = HI(адрес буфера экрана)
        rrc
        rrc
        out     90h
        lda     CHRGEN+1        ; A = HI(адрес знакогенератора)
        rrc
        rrc
        out     91h
        ret


if MOD_CCP

SetPatch:
        di
        mvi     A, 0C3h
        sta     0F86Eh          ; JUMP на пользовательский обработчик прерывания
        lxi     H, PatchPal
        shld    0F86Fh          ; адрес пользовательского обработчика
        ei
        ret

;------------------------------------------------------------------------
; патч, убирающий с BIOS обновление регистров видеоадаптера и палитры
;------------------------------------------------------------------------
PatchPal:
        ; запрещаем BIOS обновлять регистры палитры в видеорежиме 1
        inx     SP              ; убрали ret со стека
        inx     SP
        push    B
        push    D
        push    H
        push    PSW
        jmp     24F2h
;------------------------------------------------------------------------
; установка дефолтного знакогенератора из BIOS
;------------------------------------------------------------------------
chgSetDefault:
        di
        in      80h
        push    PSW
        mvi     A, 0FCh
        out     80h
        lhld    CHRGEN
        xchg
        lxi     H, 3800h
        lxi     B, 2048
        call    5Ch
        pop     PSW
        out     80h
        ei
        ret

else

SetPatch:
        ; вешаем свой обработчик, на случай вызова функций BIOS
        lxi     H, PatchPal
        lxi     D, INTVID      ; свободная область памяти, используем под обработчик
        mvi     B, PatchEnd-PatchPal+1
    @setmmove:
        mov     A, M
        inx     H
        stax    D
        inx     D
        dcr     B
        jnz     @setmmove
        di
        mvi     A, 0C3h
        sta     0F86Eh          ; JUMP на пользовательский обработчик прерывания
        lxi     H, INTVID
        shld    0F86Fh          ; адрес пользовательского обработчика
        ei
        ret

;------------------------------------------------------------------------
; патч, убирающий с BIOS обновление регистров видеоадаптера и палитры
;------------------------------------------------------------------------
PatchPal:
        ; запрещаем BIOS обновлять регистры палитры в видеорежиме 1
        inx     SP              ; убрали ret со стека
        inx     SP
        push    B
        push    D
        push    H
        push    PSW
        jmp     24F2h
;------------------------------------------------------------------------
; установка дефолтного знакогенератора из BIOS
;------------------------------------------------------------------------
chgSetDefault   equ ($-PatchPal)+INTVID
        di
        in      80h
        push    PSW
        mvi     A, 0FCh
        out     80h
        lhld    CHRGEN
        xchg
        lxi     H, 3800h
        lxi     B, 2048
        call    5Ch
        pop     PSW
        out     80h
        ei
        ret

PatchEnd:

endif

;============================================================================;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ПАЛИТРА ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;============================================================================;

;------------------------------------------------------------------------
; установка дефолтной палитры для менеджера 1
;------------------------------------------------------------------------
vidDefPalette:
        xra     A
        mvi     C, 32
        lxi     H, palNC
;------------------------------------------------------------------------
; установка палитры для видеорежима 1
;------------------------------------------------------------------------
; на входе:
;     A - first col
;     C - num col
;    HL - таблица цветов для всех 32 групп
vidSetPalette:
        ; ждем прихода прерывания
        ei
        hlt
        ; теперь можно менять палитру
        adi     0A0h
        mov     B, A            ; B - cur index
        call    vidDispOff
        ; заполянем регистры видеоадаптера
        mvi     A, 0A0h
    @spal_loop:
        mov     A, B
        sta     @spal_port+1
        mov     A, M
    @spal_port:
        out     0
        inx     H
        inr     B
        dcr     C
        jnz     @spal_loop

vidDispOn:
        ; разрешаем отображение на экран
        in      86h
        ori     10h
        out     86h
        ei
        ret

vidDispOff:
        di
        ; гасим экран
        in      86h
        ani     0EFh
        out     86h
        ret






;============================================================================;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ПРИМИТИВЫ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;============================================================================;


;------------------------------------------------------------------------
; возвращает адрес видеопамяти по заданным координатам
;------------------------------------------------------------------------
; на входе:
;    C  - x
;    E  - y
; на выходе:
;    HL - адрес видеопамяти
; save: BC, DE
vidGetAddr:
        push    B
        push    D
        lhld    BUFSCR
        xchg                    ; DE = BUFSCR
        mvi     H, 0            ; HL = Y
        mvi     B, 0            ; BC = X
        dad     H               ; Y *= 2
        dad     H               ; Y *= 4
        dad     H               ; Y *= 8
        dad     H               ; Y *= 16
        dad     H               ; Y *= 32
        dad     D               ;
        dad     B               ; HL = BUFSCR + (Y*32) + X
        pop     D
        pop     B
        ret




;;------------------------------------------------------------------------
;; установка курсора
;;------------------------------------------------------------------------
;; на входе:
;;    C  - x
;;    E  - y
;vidSetCursor:
;        lda     SCRFUL
;        dcr     A
;        cmp     C       ; (scrWidth-1) > x ?
;        rc
;        mov     A, E
;        cpi     24
;        rnc
;        ; восстанавливаем фон под курсором в текущем положении
;        lda     CURHIDE
;        ora     A
;        jnz     @newcur
;        lhld    CURBADR
;        lda     CURBKGR
;        mov     M, A
;    @newcur:
;        di
;        mov     A, C
;        sta     CURX
;        mov     A, E
;        sta     CURY
;        call    vidGetAddr
;        mov     A, M
;        sta     CURBKGR
;        shld    CURBADR
;        ei
;        ret





;------------------------------------------------------------------------
; очистка буфера экрана для режимов 0 и 1
;------------------------------------------------------------------------
vidClear:
        lhld    BUFSCR
        lda     VMODE
        cpi     1
        jnz     cls0
        ; очистка экрана для режима 1
        lxi     B, 768          ; 32*24
        mvi     D, 20h
    clslp:
        mov     M, D
        inx     H
        dcx     B
        mov     A, B
        ora     C
        jnz     clslp
    rstcur:
        ; устанавливаем курсор в верхний левый угол
;        mvi     A, ' '
;        sta     CURBKGR
;        xra     A
;        sta     CURX
;        sta     CURY
;        lhld    BUFSCR
;        shld    CURBADR         ; курсор за пределами экрана
        ret
    cls0:
        ; очистка экрана для режима 0
        rnc
        mvi     C, 24
    cl0lp:
        ; заполняем невидимую левую часть строки
        lda     LFHIDE
        mvi     B, 0
        call    cl0fil
        ; заполняем видимую часть строки
        lda     SCRWDT
        mvi     B, ' '
        call    cl0fil
        ; заполняем правую часть строки
        lda     RTHIDE
        sui     5
        call    cl0fil
        mvi     A, 5       ;5     ; заканчиваем строку кодами '5 6 0D 0E 00'
        mov     M, A
        inr     A          ;6
        inx     H
        mov     M, A
        mvi     A, 0Dh     ;0D
        inx     H
        mov     M, A
        inr     A          ;0E
        inx     H
        mov     M, A
        inx     H
        mvi     B, 0
        mov     M, B
        inx     H
        ; переходим к следующей строке
        dcr     C
        jnz     cl0lp
        jmp     rstcur

    cl0fil:
        ana     A
        rz
        mov     M, B
        inx     H
        dcr     A
        jnz     cl0fil
        ret






;============================================================================;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ЗНАКОГЕНЕРАТОР ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;============================================================================;

;------------------------------------------------------------------------
; Установка нового битового образа символа в знакогенераторе
;------------------------------------------------------------------------
; на входе:
;       BC      - адрес битового образа символа (8 байт)
;        E      - заменяемый символ
; на выходе:
;       BC      - адрес за битовым образом символа (след. образ)
; destroy: A
chgSetChar:
        push    D
        push    H
        mvi     D, 0
        xchg
        dad     H               ; HL * 2
        dad     H
        dad     H
        xchg
        lhld    CHRGEN
        dad     D               ; HL = &CharGen[Symb]
        mvi     E, 8
        di
    @chgnl:
        ldax    B
        mov     M, A
        inx     B
        inx     H
        dcr     E
        jnz     @chgnl
        ei
        pop     H
        pop     D
        ret


;------------------------------------------------------------------------
; Копирование с инвертированием битового образа символа в знакогенераторе
;------------------------------------------------------------------------
; на входе:
;       C       - исходный символ
;       E       - куда будем копировать
; save: BC,DE,HL
chgSetInvChar:
        mvi     A, 2Fh          ; cma
        sta     ChgCmd
        jmp     ChrRun
;------------------------------------------------------------------------
; Копирование битового образа символа в знакогенераторе
;------------------------------------------------------------------------
; на входе:
;       C       - исходный символ
;       E       - куда будем копировать
chgCopyChar:
        mvi     A, 00h          ; nop
        sta     ChgCmd
  ChrRun:
        push    H
        push    B
        push    D
        mvi     D, 0
        lhld    CHRGEN
        xchg
        dad     H
        dad     H
        dad     H
        dad     D               ; HL = &CharGen[Dest]
        mov     E, C
        mvi     D, 0
        mov     C, L
        mov     B, H            ; BC = &CharGen[Dest]
        lhld    CHRGEN
        xchg
        dad     H
        dad     H
        dad     H
        dad     D               ; HL = &CharGen[Source]
        mvi     E, 8
    @chgclp:
        mov     A, M
    ChgCmd:
        nop
        stax    B
        inx     H
        inx     B
        dcr     E
        jnz     @chgclp
        pop     D
        pop     B
        pop     H
        ret

;------------------------------------------------------------------------
; Создание строки в знакогенераторе
;------------------------------------------------------------------------
; на входе:
;    [SP+2] - строка
;     C     - длина строки
;     E     - позиция в знакогенераторе (0-255)
; save: HL, BC
chgSetString:
        mvi     A, 00h          ; nop
        sta     invcmd
  GenRun:
        pop     H
        xthl                    ; HL - строка
        push    B
        mov     A, C            ; A - длина строки, E - нач. символ в знакогенераторе
        mov     C, L            ; BC - строка
        mov     B, H
        ; вычисляем адрес в знакогенераторе
        mvi     D, 0
        lhld    CHRGEN
        xchg
        dad     H               ; char*2
        dad     H               ; char*4
        dad     H               ; char*8
        dad     D               ; HL = &chargen[E]
        ; инвертируем строку
        xchg
    @CGs0:
        push    PSW
        ldax    B               ; A = char
        inx     B
        push    B
        lhld    CHRGEN
        mov     C, L
        mov     B, H
        mov     L, A
        mvi     H, 0
        dad     H               ; char*2
        dad     H               ; char*4
        dad     H               ; char*8
        dad     B               ; HL = &chargen[char*8]
        ; инвертируем один символ
        mvi     C, 8
    @CGs1:
        mov     A, M
  invcmd:
        cma
        stax    D
        inx     H
        inx     D
        dcr     C
        jnz     @CGs1
        pop     B
        pop     PSW
        dcr     A
        jnz     @CGs0
        pop     B
        ret


;------------------------------------------------------------------------
; Создание инвертированной строки в знакогенераторе
;------------------------------------------------------------------------
; на входе:
;    [SP+2] - строка
;     C     - длина строки
;     E     - позиция в знакогенераторе (0-255)
; save: HL, BC
chgInvString:
        mvi     A, 2Fh          ; cma
        sta     invcmd
        jmp     GenRun



;------------------------------------------------------------------------
; занос в буфер строки из знакогенератора
;------------------------------------------------------------------------
; на входе:
;       DE      - буфер
;        C      - кол. символов
;        B      - знакоместо
; save: HL
chgGetString:
        mov     A, C
        ora     A
        rz
        mov     A, B
    @inscgl:
        stax    D
        inx     D
        inr     A
        dcr     C
        jnz     @inscgl
        ret




;============================================================================;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ОКНА ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░;
;============================================================================;


; смещения полей структуры WND
  WNAMELEN      equ 0
  WTEXTNAME     equ 1
  WX            equ 7           ; координаты окна
  WY            equ 8
  WCOLNS        equ 9           ; ширина окна
  WROWS         equ 10          ; высота окна
  WBORDER       equ 11          ; тип бордюра (8h, 10h и 18h)
  WBACKGR       equ 12          ; символ закрашивания фона
  WSVBUF        equ 13          ; адрес буфера для сохранения фона под окном


;------------------------------------------------------------------------
; возвращает адрес памяти под сохраненный фон
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;    HL - адрес буфера
wndGetBuff:
        push    D
        lxi     H, WSVBUF
        dad     B
        mov     E, M
        inx     H
        mov     D, M
        xchg
        pop     D
        ret

;------------------------------------------------------------------------
; возвращает тип бордюра
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;     A - тип бордюра (0h, 10h и 18h)
wndGetBord:
        push    H
        lxi     H, WBORDER
        dad     B
        mov     A, M
        pop     H
        ret

;------------------------------------------------------------------------
; возвращает символ для закрашивания фона окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;     A - символ
wndGetBkGr:
        push    H
        lxi     H, WBACKGR
        dad     B
        mov     A, M
        pop     H
        ret

;------------------------------------------------------------------------
; возвращает ширину клиентской части окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;     A - ширина клиентской части окна
;    CF - =1, если ширина окна меньше 2
; save: ALL (exclude A)
wndGetWidth:
        push    H
        lxi     H, WCOLNS
    WGetCl:
        dad     B
        mov     A, M
        sui     2
        pop     H
        ret

;------------------------------------------------------------------------
; возвращает высоту клиентской части окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;     A - высота клиентской части окна
;    CF - =1, если высота окна меньше 2
; save: ALL (exclude A)
wndGetHeight:
        push    H
        lxi     H, WROWS
        jmp     WGetCl


;------------------------------------------------------------------------
; вычисляет адрес видеопамяти начала окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;    HL - адрес видеопамяти
; save: BC, DE
wndGetAddr:
        push    B
        push    D
        lxi     H, WX
        dad     B
        mov     C, M
        inx     H
        mov     E, M
        inx     H
        call    vidGetAddr      ; HL - vid mem
        pop     D
        pop     B
        ret


;------------------------------------------------------------------------
; вычисляет адрес видеопамяти начала клиентской части окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;    HL - адрес видеопамяти
wndGetClient:
        lxi     D, 0
;------------------------------------------------------------------------
; вычисляет адрес видеопамяти по заданным координатам курсора
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
;    D  - x
;    E  - y
; на выходе:
;    HL - адрес видеопамяти
; save: BC, DE
wndGetOffs:
        push    B
        push    D
        lxi     H, WY
        dad     B
        mov     A, M
        inr     A
        add     E
        mov     E, A
        dcx     H
        mov     A, M
        inr     A
        add     D
        mov     C, A
        call    vidGetAddr      ; HL - vid mem
        pop     D
        pop     B
        ret


;------------------------------------------------------------------------
; вывод названия окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; destroy: all
wndDrawName:
        call    wndGetAddr      ; HL = &vid mem, DE = &Wnd.Width
        call    wndGetWidth     ; A = Wnd.Width-2
        mov     D, A
        ldax    B
        ora     A               ; if length(Wnd.Name) = 0 then
        rz                      ;     return
        inx     B               ; BC = &Wnd.Name
        mov     E, A            ; E = length(Wnd.Name)
        mov     A, D
        sub     E               ; A = (width-2)-length
        jnc     wnam0
        xra     A
        mov     E, D            ; E = width-2
    wnam0:
        rar
        ani     7Fh
        inr     A
        add     L
        mov     L, A
        mov     A, H
        aci     0
        mov     H, A            ; HL = &vid mem + ( ((width-2)-length) / 2)
    wnamput:
        ldax    B
        mov     M, A
        inx     B
        inx     H
        dcr     E
        jnz     wnamput
        ret



;------------------------------------------------------------------------
; вывод заголовка и рамки окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
wndDrawBorder:
        call    wndGetAddr      ; HL = &vid mem
        call    wndGetWidth
        mov     E, A            ; E - width
        call    wndGetHeight
        mov     D, A            ; D - height
        push    B
        push    H
        call    wndGetBord
        mov     B, A
        lda     SCRFUL
        mov     C, A
        mov     A, B
        mvi     B, 0            ; BC - screen width

        mov     M, A            ; ┌
        inx     H
        push    D
        inr     A
    @frhor:
        mov     M, A            ; ─
        inx     H
        dcr     E
        jnz     @frhor

        inr     A
        mov     M, A            ; ┐
        dad     B

        inr     A
    @frrgh:
        mov     M, A            ; │
        dad     B
        dcr     D
        jnz     @frrgh

        inr     A
        mov     M, A            ; ┘
        dcx     H

        pop     D
        inr     A
    @frbott:
        mov     M, A            ; ─
        dcx     H
        dcr     E
        jnz     @frbott

        inr     A
        mov     M, A            ; └

        inr     A

        pop     H
        dad     B
    @frleft:
        mov     M, A            ; │
        dad     B
        dcr     D
        jnz     @frleft

        pop     B
        call    wndDrawName
        ret



;------------------------------------------------------------------------
; вывод окна на экран
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
wndShow:
        ; выводим название окна и рамку
        push    B
        call    wndDrawBorder
        ; очищаем окно
        pop     B
        call    wndClear
        ret


;------------------------------------------------------------------------
; очистка окна
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
wndClear:
        push    B               ; сохраняем адрес структуры окна
        call    wndGetClient    ; HL = адрес начала клиентской части окна
        call    wndGetWidth
        mov     D, A            ; D = ClientWidth(Wnd)
        call    wndGetHeight
        mov     E, A            ; E = ClientHeight(Wnd)-1
        call    wndGetBkGr
        mov     B, A
        lda     SCRFUL          ; A = ScreenWidth
        sub     D               ; A = ScreenWidth-Wnd.ClientWidth
        mov     C, A            ; C = ScreenIncrement
        mov     A, B
    wclsver:
        mov     B, D            ; B = width count
    wclshor:
        mov     M, A
        inx     H
        dcr     B
        jnz     wclshor
        dad     B               ; HL += screen increment
        dcr     E
        jnz     wclsver
        pop     B
        ret


;------------------------------------------------------------------------
; разделяет окно
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
wndDrawSplit:
        call    wndGetHeight
        dcr     A
        rz
        rc
        dcr     A
        rz
        mov     E, A
        mvi     D, 0
        call    wndGetOffs
        dcx     H               ; HL - vid mem
        call    wndGetWidth
        mov     E, A            ; E - client width
        call    wndGetBord
        adi     8
        mov     M, A
        inx     H
        inr     A
    @spl_loop:
        mov     M, A
        inx     H
        dcr     E
        jnz     @spl_loop
        inr     A
        mov     M, A
        ret

;------------------------------------------------------------------------
; возвращает адрес видеопамяти начала split-области
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; на выходе:
;    HL - адрес split-области
wndGetSplit:
        call    wndGetHeight
        dcr     A
        mov     E, A
        mvi     D, 0
        call    wndGetOffs
        ret





;------------------------------------------------------------------------
; вывод строк в диалоговое окно
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
;    DE - массив asciiz-строк (конец массива обозначен как '$')
wndPutStrings:
        push    B
        push    D
        call    wndGetClient    ; HL = адрес начала клиентской части окна
        call    wndGetWidth
        push    PSW
        call    wndGetHeight
        mov     C, A
        pop     PSW
        mov     B, A
        pop     D
        ; HL - vid mem
        ; DE - str ptr
        ; B - window width
        ; C - window height
    @WDslp:
        ldax    D
        cpi     '$'
        jz      @WDExit
        call    lenstr
        push    B
        ora     A
        jz      @WDnxt
        push    H
        ; центрируем строку
        mov     C, A            ; C - len str
        mov     A, B
        sub     C               ; A = width - len(str)
        ana     A
        rar
        add     L
        mov     L, A
        mov     A, H
        aci     0
        mov     H, A            ; HL += (width - len(str)) / 2
        ; выводим её в окно
    @WDps:
        ldax    D
        mov     M, A
        inx     H
        inx     D
        dcr     C
        jnz     @WDps
        ; переходим на следующую
        pop     H
    @WDnxt:
        lda     SCRFUL
        mov     C, A
        mvi     B, 0
        dad     B               ; HL = next window line
        pop     B
        inx     D
        dcr     C
        jnz     @WDslp

    @WDExit:
        pop     B
        ret

lenstr:
        push    D
        push    B
        mvi     C, 0
    @lnstr:
        ldax    D
        ora     A
        jz      @lnsen
        inx     D
        inr     C
        jmp     @lnstr
    @lnsen:
        mov     A, C
        pop     B
        pop     D
        ret

; копирует строку длиной C из HL в DE
@mcpy:
        push    B
    @memcp:
        mov     A, M
        stax    D
        inx     H
        inx     D
        dcr     C
        jnz     @memcp
        pop     B
        ret


;------------------------------------------------------------------------
; сохраняет экран "под" окном
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
wndSaveBkGr:
        push    B
        call    wndGetBuff
        xchg                    ; DE - buff ptr
        call    wndGetWidth
        adi     2
        mov     H, A
        call    wndGetHeight
        adi     2
        mov     L, A
        push    H
        call    wndGetAddr      ; HL - vid mem
        pop     B               ; B - width, C - height

    @WSvlp:
        push    B
        push    H
    @WSvwl:
        mov     A, M
        stax    D
        inx     D
        inx     H
        dcr     B
        jnz     @WSvwl
        pop     H
        lda     SCRFUL
        mov     C, A
        mvi     B, 0
        dad     B
        pop     B
        dcr     C
        jnz     @WSvlp
        pop     B
        ret

;------------------------------------------------------------------------
; восстанавливает экран "под" окном
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
wndHide:
        push    B
        call    wndGetBuff      ; HL - buff ptr
        xchg                    ; DE - vid mem
        call    wndGetWidth
        adi     2
        mov     H, A
        call    wndGetHeight
        adi     2
        mov     L, A
        push    H
        call    wndGetAddr
        pop     B               ; B - width, C - height
    @WRslp:
        push    B
        push    H
    @WRswl:
        ldax    D
        mov     M, A
        inx     D
        inx     H
        dcr     B
        jnz     @WRswl
        pop     H
        lda     SCRFUL
        mov     C, A
        mvi     B, 0
        dad     B
        pop     B
        dcr     C
        jnz     @WRslp
        pop     B
        ret



;------------------------------------------------------------------------
; отрисовка курсора в заданной строке (на всю ширину окна)
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
;    E  - номер строки
wndShowCursor:
;        call    wndGetHeight
;        dcr     A
;        cmp     E
;        jnc     @wcshow_run
;        mov     E, A            ; корректируем курсор
;    @wcshow_run:
        mvi     D, 0
        call    wndGetOffs      ; HL = адрес видеопамяти клиентской части окна
        mov     A, E
        lxi     D, BUFSAV
        stax    D               ; сохраняем в буфер номер строки
        inx     D
        call    wndGetWidth
        mov     C, A            ; B = длина строки
        push    H
        push    H               ; параметр для chgSetString
        call    @mcpy          ; сохраняем саму строку
        mvi     E, 0A0h
        call    chgSetString
        ; подменяем строку на новую
        pop     D
        mvi     B, 0A0h
        jmp     chgGetString



;------------------------------------------------------------------------
; восстанавливает строку под курсором
;------------------------------------------------------------------------
; на входе:
;    BC - адрес структуры окна
; save:
;    BC
wndHideCursor:
        push    B
        lxi     H, BUFSAV
        mov     E, M
        mvi     D, 0
        call    wndGetOffs      ; HL = &vidmem
        lxi     D, BUFSAV+1
        xchg
        call    wndGetWidth     ; A = длина строки
        mov     C, A
        call    @mcpy
        pop     B
        ret







; таблицы параметров видеорежимов 0 и 1
regsMode0:
  db    64              ; полная ширина экрана, включая не отображаемые области
  db    0               ; кол. не отображаемых символов слева
  db    40              ; видимая ширина экрана
  db    24              ; кол. строк экрана
  db    24              ; кол. пропускаемых символов справа
  dw    0E000h          ; адрес буфера экрана реж. 0 и 1
  dw    0E400h          ; адрес таб. цвета реж. 1
  dw    0F000h          ; адрес знакогенератора реж. 0 и 1
  db    0               ; номер видеорежима

regsMode1:
  db    32              ; полная ширина экрана, включая не отображаемые области
  db    0               ; кол. не отображаемых символов слева
  db    32              ; видимая ширина экрана
  db    24              ; кол. строк экрана
  db    00              ; кол. пропускаемых символов справа
  dw    0E000h          ; адрес буфера экрана реж. 0 и 1
  dw    0E400h          ; адрес таб. цвета реж. 1
  dw    0F000h          ; адрес знакогенератора реж. 0 и 1
  db    1               ; номер видеорежима

; дефолтная таблица цвета
palNC:
  db 08Fh,0EFh,047h,047h,04Fh,04Fh,04Fh,04Fh
;     ^    ^    ^    ^    ^    ^    ^    ^
;     |    |    |    |    |    |    |    +--- 38
;     |    |    |    |    |    |    +-------- 30
;     |    |    |    |    |    +------------- 28
;     |    |    |    |    +------------------ 20
;     |    |    |    +----------------------- 18 голубые спецсимволы
;     |    |    +---------------------------- 10 голубой бордюр
;     |    +--------------------------------- 08 серый бордюр
;     +-------------------------------------- 00 красный бордюр

  db 04Fh,04Fh,04Fh,04Fh,04Fh,04Fh,04Fh,04Fh
  db 047h,0EFh,061h,061h,061h,061h,0EFh,0EFh
;     ^    ^    ^    ^    ^    ^    ^    ^
;     |    |    |    |    |    |    |    +--- B8 -   алфавит серых окон
;     |    |    |    |    |    |    |      /- B1 -   заголовки сер. окон
;     |    |    |    |    |    |    +-----+-- B0 -   фон сер. окон
;     |    |    |    |    |    +------------- A8 -   курсор выбора
;     |    |    |    |    +------------------ A0 -   курсор выбора
;     |    |    |    +----------------------- 98 -\ клавиши
;     |    |    +---------------------------- 90 -/ F1-F10
;     |    +--------------------------------- 88 имена серых окон
;     +-------------------------------------- 80 имена панелей
  db 0EFh,0EFh,0EFh,08Fh,08Fh,08Fh,08Fh,08Fh
;     ^    ^    ^    ^    ^    ^    ^    ^
;     |    |    |    |    |    |    |    +--- F8 -\
;     |    |    |    |    |    |    +-------- F0   \ алфавит красных окон
;     |    |    |    |    |    +------------- E8   /
;     |    |    |    |    +------------------ E0 -/
;     |    |    |    |                     /- D9 -   заголовки кр. окон
;     |    |    |    +--------------------+-- D8 -   фон кр. окон
;     |    |    +---------------------------- D0 -\
;     |    +--------------------------------- C8   > алфавит серых окон
;     +-------------------------------------- C0 -/


; палитра для вывода справки
palHelp:
  db 0EFh,0EFh,0EFh,0EFh,0EFh,0EFh
  db 0EFh,0EFh,0EFh,0EFh
